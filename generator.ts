// import { generatorHandler } from "@prisma/generator-helper";
import generatorHelper from "@prisma/generator-helper";
import { resolve as resolvePath } from "node:path";
import type { DMMF } from "@prisma/generator-helper";

import { Config } from "./libs/config/config.js";
import { DEFAULT_SCHEMA_SUFFIX } from "./libs/config/config.js";
import { validateConfig } from "./libs/utils/validateConfig.js";
import { writeTsFile } from "./libs/utils/writeTsFile.js";

import { generateEnumFileInline } from "./libs/renderers/enumRenderer.js";
import { generateModelFileInline } from "./libs/renderers/modelRenderer.js";
import { generateComplexTypeInline } from "./libs/renderers/complexTypeRenderer.js";
const { generatorHandler } = generatorHelper;

generatorHandler({
  onManifest() {
    return {
      prettyName: "Prisma DTO Generator (Refactored Inline)",
      defaultOutput: "./generated",
    };
  },
  async onGenerate(options) {
    // 1) Build config from options
    const baseConfig = options.generator.config;
    const config: Config = {
      enumPrefix: "",
      enumSuffix: "",
      modelPrefix: "",
      modelSuffix: "",
      typePrefix: "",
      typeSuffix: "",
      headerComment: "Auto-generated by prisma-dto-gen (refactored inline)",
      modelType: "interface",
      enumType: "stringUnion",
      dateType: "Date",
      bigIntType: "bigint",
      decimalType: "Decimal",
      bytesType: "Buffer",
      optionalRelations: baseConfig.optionalRelations !== "false",
      omitRelations: baseConfig.omitRelations === "true",
      optionalNullables: baseConfig.optionalNullables === "true",
      prettier: baseConfig.prettier === "true",
      resolvePrettierConfig: baseConfig.resolvePrettierConfig !== "false",
      appendExtensions: baseConfig.appendExtensions === "true",
      schema: baseConfig.schema === "zod" ? "zod" : null,
      schemaPrefix: String(baseConfig.schemaPrefix || ""),
      schemaSuffix: String(baseConfig.schemaSuffix || DEFAULT_SCHEMA_SUFFIX),
      fileExtension: (baseConfig.fileExtension as Config["fileExtension"]) || ".js",
    };
    validateConfig(config);

    // 2) Gather data
    const outputDir = options.generator.output?.value ?? "./generated";
    const { datamodel, schema } = options.dmmf;
    const { models = [], enums = [], types = [] } = datamodel;

    const inputObjectTypes = [
      ...(schema.inputObjectTypes?.prisma ?? []),
      ...(schema.inputObjectTypes?.model ?? []),
    ];
    const outputObjectTypes = [
      ...(schema.outputObjectTypes?.prisma ?? []),
      ...(schema.outputObjectTypes?.model ?? []),
    ];

    // Build maps
    const enumMap = new Map<string, DMMF.DatamodelEnum>(enums.map((e) => [e.name, e]));
    const modelMap = new Map<string, DMMF.Model>(models.map((m) => [m.name, m]));

    for (const t of types) {
      modelMap.set(t.name, t);
    }

    // 3) Generate enum files
    const enumFiles: string[] = [];
    for (const e of enums) {
      const content = generateEnumFileInline(e, config);
      const filePath = resolvePath(outputDir, `enum_${e.name}.ts`);
      await writeTsFile({ filePath, content, config });
      enumFiles.push(filePath);
    }

    // 4) Generate model files
    const modelFiles: string[] = [];
    for (const m of models) {
      const content = generateModelFileInline(m, [...models, ...types], enumMap, modelMap, config);
      const filePath = resolvePath(outputDir, `model_${m.name}.ts`);
      await writeTsFile({ filePath, content, config });
      modelFiles.push(filePath);
    }
    for (const t of types) {
      const content = generateModelFileInline(t, [...models, ...types], enumMap, modelMap, config);
      const filePath = resolvePath(outputDir, `type_${t.name}.ts`);
      await writeTsFile({ filePath, content, config });
      modelFiles.push(filePath);
    }

    // 5) Generate input object files
    const inputTypeFiles: string[] = [];
    for (const io of inputObjectTypes) {
      const content = generateComplexTypeInline(
        io,
        [...models, ...types],
        enumMap,
        modelMap,
        config,
        true,
      );
      const filePath = resolvePath(outputDir, `input_${io.name}.ts`);
      await writeTsFile({ filePath, content, config });
      inputTypeFiles.push(filePath);
    }

    // 6) Generate output object files
    const outputTypeFiles: string[] = [];
    for (const oo of outputObjectTypes) {
      const content = generateComplexTypeInline(
        oo,
        [...models, ...types],
        enumMap,
        modelMap,
        config,
        false,
      );
      const filePath = resolvePath(outputDir, `output_${oo.name}Output.ts`);
      await writeTsFile({ filePath, content, config });
      outputTypeFiles.push(filePath);
    }

    // 7) Create index.ts that re-exports everything
    const allFiles = [...enumFiles, ...modelFiles, ...inputTypeFiles, ...outputTypeFiles];
    const imports = allFiles.map((filePath) => {
      let relativePath = "./" + filePath.replace(outputDir, "").replace(/^\//, "");
      const extension = config.fileExtension === null ? "" : config.fileExtension;
      relativePath = relativePath.replace(/\.ts$/, extension);
      return `export * from "${relativePath}";`;
    });
    const indexContent = imports.join("\n");
    const indexPath = resolvePath(outputDir, "index.ts");
    await writeTsFile({ filePath: indexPath, content: indexContent, config });
  },
});
